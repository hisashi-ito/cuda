#### SpMv計算
Eigen3を利用して単純なSpMv計算を実行し、１回のspmv計算の計算時間そ測定するベンチマークプログラム。  

本プログラムはCOO 形式の行列を読み込みEigen3のライブラリを利用してCRS形式へ変換しSparse Mmatrix vector 演算(SPMV)計算を実行し、この実行時に1回のspmvにかかる計算時間(ミリsec)を測定するものである。  
本実装はEigenライブラリを用いて実装しているEigenライブラリは高速でかつ、本体のライブラリがヘッダファイルで提供されているのでコンパイル時に利用ヘッダファイルをリンクするだけでよい。
また本実装はOpenMPによるマルチスレッド実行に対応している。
#### Eigen3 について
Eigen  
http://eigen.tuxfamily.org/index.php?title=Main_Page  
最新のバージョは3.3.4  

##### 並列化(OpenMP)の動作
並列化の方針、本実装は共有メモリに計算する行列を保存にこの共有メモリに対して複数の異なるベクトルをマルチスレッドで指定回数乗算する並列アルゴリズムとしている。概念図で記載すると以下の通りような動作をしている。

<p align="center">
<img src="https://user-images.githubusercontent.com/8604827/40163477-d869a11e-59f1-11e8-97df-1e20244c6f58.png" width="450px">
</p>

ここで、行列は１つのホストの共有メモリに保存されているとして、この状況下で複数のCPU、上記の図では３つのCPUで並列化を実施しているイメージを記載している。そして、３つのCPUでspmv計算を実行するためのベクトルを事前に10個用意されているとする。  
ここで、CPU1は ベクトル1~4, CPU2は ベクトル5~7, CPU3は ベクトル8~10 の処理を受け持つとする。このベクトルの個数というのが引数(-n)で指定する数値となっている。一般的にCPUの個数の粒度を揃えるためには

```
利用するCPUの個数 << n (初期ベクトル数)
```
であることが期待される。一般的なIntel社のi7CPUだと8コア程度なので、デフォルトではだいたい100ぐらいを想定しておけばCPUに割り当てられるタスクの粒度を揃えることが

##### コンパイル方法
```
$ cd src/
$ make
```
※ 実行環境には g++ がインストールされていることを想定とする。

##### 実行方法
```
$ ./SPMV -i <遷移行列> (COO格納形式) -t <iteratoin回数> -n <初期ベクトルの数>
```
##### ファイルフォーマット
1. 遷移行列(COO格納形式)  
計算で利用する遷移行列をCOO形式で保存する。フィールドセパレータはカンマ','文字列とする
```
0,0,1.0
0,1,2.0
0,2,3.0
1,0,4.0
1,1,5.0
1,2,6.0
2,0,7.0
2,1.8.0
2,2,9.0
```
2. iteratoin回数は spmv計算を繰り返し実施し、平均をとるため設定する数値、100程度を想定している。  
3. 初期ベクトルの数
